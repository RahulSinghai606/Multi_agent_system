# Master Agent + Multi-Agent Integration Guide

Complete guide for integrating multi-agent orchestration into Master Agent workflows.

## Overview

Master Agent now supports orchestration across multiple AI providers (Claude, Gemini, Copilot, OpenAI), enabling:
- **Intelligent routing** based on agent capabilities
- **Parallel execution** for consensus-based decisions
- **Automatic fallback** for reliability
- **Sequential pipelines** for complex workflows

## Quick Integration

### 1. Import Multi-Agent Components

```python
from core import (
    MultiAgentOrchestrator,
    Task,
    TaskType,
    AgentCapability,
    get_registry
)
```

### 2. Initialize Orchestrator

```python
# In your workflow initialization
orchestrator = MultiAgentOrchestrator()

# Verify agents are healthy
registry = get_registry()
health = registry.get_health_report()
print(f"Healthy agents: {health['healthy_agents']}/{health['total_agents']}")
```

### 3. Execute Tasks

```python
# Create task
task = Task(
    type=TaskType.CODE_GENERATION,
    description="Implement user authentication",
    context={
        "system": "Generate production-ready code",
        "temperature": 0.7,
        "max_tokens": 4000
    },
    required_capability=AgentCapability.CODE_GENERATION
)

# Execute with best agent
result = await orchestrator.execute_task(task, strategy="best_agent")

if result.success:
    print(f"Generated by {result.agent_name}:")
    print(result.response.content)
```

## Integration Patterns

### Pattern 1: Enhanced Persona Execution

Enhance existing Master Agent personas with multi-agent capabilities.

**Before (Single Agent):**
```python
class Architect:
    def design_system(self, requirements):
        # Uses only Claude
        prompt = f"Design system for: {requirements}"
        response = claude_api.generate(prompt)
        return response
```

**After (Multi-Agent):**
```python
class Architect:
    def __init__(self):
        self.orchestrator = MultiAgentOrchestrator()

    async def design_system(self, requirements):
        # Uses best available agent (Claude, Gemini, or OpenAI)
        task = Task(
            type=TaskType.ARCHITECTURE_DESIGN,
            description=f"Design system for: {requirements}",
            required_capability=AgentCapability.ARCHITECTURE
        )

        result = await self.orchestrator.execute_task(
            task,
            strategy="fallback"  # Automatic retry if first agent fails
        )

        return result.response.content
```

**Benefits:**
- Automatic fallback if Claude API is down
- Can leverage Gemini's long context (1M+ tokens)
- No code changes needed if you switch preferred agent

### Pattern 2: Multimodal PRD Analysis

Use Gemini's vision capabilities for analyzing PRDs with diagrams.

```python
class PRDProcessor:
    def __init__(self):
        self.orchestrator = MultiAgentOrchestrator()

    async def analyze_prd_with_diagrams(self, prd_text, diagram_images):
        """
        Analyze PRD including visual diagrams

        Args:
            prd_text: PRD markdown content
            diagram_images: List of base64-encoded diagram images
        """
        task = Task(
            type=TaskType.MULTIMODAL_ANALYSIS,
            description=f"""
            Analyze this PRD including diagrams:

            {prd_text}

            Extract:
            1. System architecture from diagrams
            2. Component relationships
            3. Data flow patterns
            4. Integration points
            """,
            context={
                "system": "Extract structured requirements from PRD and diagrams",
                "temperature": 0.3,
                "images": diagram_images  # Gemini processes these
            },
            required_capability=AgentCapability.MULTIMODAL
        )

        result = await self.orchestrator.execute_task(task)

        return {
            "requirements": result.response.content,
            "diagrams_analyzed": len(diagram_images),
            "agent": result.agent_name
        }
```

**Use Case:**
```python
# In Design phase
prd_content = load_prd("feature.md")
diagrams = extract_diagrams(prd_content)  # PNG/JPG images

processor = PRDProcessor()
analysis = await processor.analyze_prd_with_diagrams(
    prd_text=prd_content,
    diagram_images=[base64.b64encode(img) for img in diagrams]
)

# analysis["requirements"] now includes diagram insights
```

### Pattern 3: Consensus-Based Code Review

Get multiple perspectives on critical code reviews.

```python
class QALead:
    def __init__(self):
        self.orchestrator = MultiAgentOrchestrator()

    async def comprehensive_review(self, code, risk_level="high"):
        """
        Multi-agent code review with consensus

        Args:
            code: Code to review
            risk_level: "low" | "medium" | "high"
                - low: Single agent (fast)
                - medium: Fallback strategy (reliable)
                - high: Parallel consensus (thorough)
        """
        task = Task(
            type=TaskType.CODE_REVIEW,
            description=f"""
            Review this code for:
            - Correctness and logic errors
            - Security vulnerabilities
            - Performance issues
            - Maintainability concerns
            - Best practices adherence

            Code:
            {code}
            """,
            context={
                "system": "Perform thorough code review with actionable feedback",
                "temperature": 0.2  # More deterministic
            },
            required_capability=AgentCapability.CODE_REVIEW
        )

        # Strategy based on risk level
        strategies = {
            "low": "best_agent",      # Fast, single perspective
            "medium": "fallback",     # Reliable, automatic retry
            "high": "parallel"        # Thorough, multiple perspectives
        }

        result = await self.orchestrator.execute_task(
            task,
            strategy=strategies[risk_level]
        )

        return {
            "issues_found": parse_issues(result.response.content),
            "reviewers": result.agent_name,
            "confidence": "high" if risk_level == "high" else "medium"
        }
```

**Usage:**
```python
qa_lead = QALead()

# For payment processing (high risk)
review = await qa_lead.comprehensive_review(
    payment_code,
    risk_level="high"  # Parallel consensus
)
# Multiple agents review → higher confidence

# For UI component (low risk)
review = await qa_lead.comprehensive_review(
    button_component,
    risk_level="low"  # Single agent
)
# Faster, cost-effective
```

### Pattern 4: SDLC Phase Pipelines

Create multi-step workflows with context passing between agents.

```python
class SDLCWorkflow:
    def __init__(self):
        self.orchestrator = MultiAgentOrchestrator()

    async def execute_feature_pipeline(self, feature_spec):
        """
        End-to-end feature development pipeline

        Pipeline:
        1. Design → 2. Implement → 3. Test → 4. Secure → 5. Review
        """

        # Phase 1: Architecture Design
        design_task = Task(
            type=TaskType.ARCHITECTURE_DESIGN,
            description=f"Design architecture for: {feature_spec}",
            context={"temperature": 0.5},
            required_capability=AgentCapability.ARCHITECTURE
        )

        # Phase 2: Code Generation
        implement_task = Task(
            type=TaskType.CODE_GENERATION,
            description="Implement the architecture designed in Phase 1",
            context={
                "system": "Generate production-ready code based on architecture",
                "temperature": 0.4
            },
            required_capability=AgentCapability.CODE_GENERATION
        )

        # Phase 3: Test Generation
        test_task = Task(
            type=TaskType.CODE_GENERATION,
            description="Generate comprehensive tests for code from Phase 2",
            context={
                "system": "Write unit and integration tests with 90%+ coverage",
                "temperature": 0.3
            },
            required_capability=AgentCapability.TESTING
        )

        # Phase 4: Security Audit
        security_task = Task(
            type=TaskType.SECURITY_AUDIT,
            description="Audit code from Phase 2 for vulnerabilities",
            context={
                "system": "OWASP Top 10, authentication, authorization, data validation",
                "temperature": 0.2
            },
            required_capability=AgentCapability.SECURITY
        )

        # Phase 5: Final Review
        review_task = Task(
            type=TaskType.CODE_REVIEW,
            description="Final quality gate review",
            context={
                "system": "Approve for deployment or request changes",
                "temperature": 0.3
            },
            required_capability=AgentCapability.CODE_REVIEW
        )

        # Execute pipeline
        results = await self.orchestrator.execute_pipeline([
            design_task,
            implement_task,
            test_task,
            security_task,
            review_task
        ])

        # Build comprehensive output
        return {
            "architecture": results[0].response.content if results[0].success else None,
            "implementation": results[1].response.content if results[1].success else None,
            "tests": results[2].response.content if results[2].success else None,
            "security_report": results[3].response.content if results[3].success else None,
            "review_decision": results[4].response.content if results[4].success else None,
            "total_time_ms": sum(r.execution_time_ms for r in results),
            "phases_completed": sum(1 for r in results if r.success),
            "approved": "APPROVED" in results[4].response.content if results[4].success else False
        }
```

**Usage:**
```python
workflow = SDLCWorkflow()

output = await workflow.execute_feature_pipeline(
    feature_spec="User authentication with JWT and refresh tokens"
)

if output["approved"]:
    print("✅ Feature approved for deployment!")
    deploy(output["implementation"], output["tests"])
else:
    print("❌ Changes required:")
    print(output["review_decision"])
```

### Pattern 5: Intelligent Agent Selection

Let the system choose the best agent based on task characteristics.

```python
class SmartRouter:
    def __init__(self):
        self.orchestrator = MultiAgentOrchestrator()

    async def execute_with_context_awareness(self, description, code_context):
        """
        Automatically select best strategy based on context size

        - Small context (<10K tokens): best_agent (cost-effective)
        - Medium context (10K-100K): fallback (reliable)
        - Large context (>100K): route to Gemini (1M+ tokens)
        """
        context_size = estimate_tokens(code_context)

        if context_size > 100000:
            # Force Gemini for large context
            task = Task(
                type=TaskType.CODE_GENERATION,
                description=f"{description}\n\nContext:\n{code_context}",
                context={
                    "temperature": 0.5,
                    "max_tokens": 8000
                },
                required_capability=AgentCapability.LONG_CONTEXT
            )
            strategy = "best_agent"  # Will select Gemini (1M tokens)

        elif context_size > 10000:
            # Medium context: use fallback for reliability
            task = Task(
                type=TaskType.CODE_GENERATION,
                description=f"{description}\n\nContext:\n{code_context}",
                context={"temperature": 0.5},
                required_capability=AgentCapability.CODE_GENERATION
            )
            strategy = "fallback"

        else:
            # Small context: standard execution
            task = Task(
                type=TaskType.CODE_GENERATION,
                description=f"{description}\n\nContext:\n{code_context}",
                context={"temperature": 0.5},
                required_capability=AgentCapability.CODE_GENERATION
            )
            strategy = "best_agent"

        result = await self.orchestrator.execute_task(task, strategy=strategy)
        return result
```

## Master Agent Workflow Integration

### Updated Design Phase

```python
# agents/design/architect.py

from core import MultiAgentOrchestrator, Task, TaskType, AgentCapability

class Architect:
    def __init__(self):
        self.orchestrator = MultiAgentOrchestrator()

    async def design_architecture(self, prd_content, diagrams=None):
        """
        Phase 1: Design

        With multi-agent:
        - Use Gemini for multimodal PRD analysis (if diagrams present)
        - Use Claude for architecture design
        - Automatic fallback if primary agent unavailable
        """

        # Step 1: PRD Analysis (multimodal if diagrams)
        if diagrams:
            analysis_task = Task(
                type=TaskType.MULTIMODAL_ANALYSIS,
                description=f"Analyze PRD with diagrams:\n{prd_content}",
                context={"images": diagrams},
                required_capability=AgentCapability.MULTIMODAL
            )
            analysis = await self.orchestrator.execute_task(analysis_task)
            requirements = analysis.response.content
        else:
            requirements = prd_content

        # Step 2: Architecture Design
        design_task = Task(
            type=TaskType.ARCHITECTURE_DESIGN,
            description=f"Design system architecture for:\n{requirements}",
            context={
                "system": "Create scalable, maintainable architecture",
                "temperature": 0.5
            },
            required_capability=AgentCapability.ARCHITECTURE
        )

        design = await self.orchestrator.execute_task(
            design_task,
            strategy="fallback"  # Automatic retry
        )

        return {
            "architecture": design.response.content,
            "agent": design.agent_name,
            "execution_time_ms": design.execution_time_ms
        }
```

### Updated Implementation Phase

```python
# agents/implementation/developer.py

from core import MultiAgentOrchestrator, Task, TaskType, AgentCapability

class Developer:
    def __init__(self):
        self.orchestrator = MultiAgentOrchestrator()

    async def implement_feature(self, architecture, component_name):
        """
        Phase 2: Implementation

        With multi-agent:
        - Try Copilot first (code completion specialist)
        - Fallback to Claude if Copilot unavailable
        - Automatic retry on failures
        """

        task = Task(
            type=TaskType.CODE_GENERATION,
            description=f"""
            Implement {component_name} based on architecture:

            {architecture}

            Generate:
            - Production-ready code
            - Type definitions
            - Error handling
            - Unit tests
            """,
            context={
                "system": "Generate clean, efficient, well-tested code",
                "temperature": 0.4,
                "max_tokens": 4000
            },
            required_capability=AgentCapability.CODE_GENERATION
        )

        result = await self.orchestrator.execute_task(
            task,
            strategy="fallback"
        )

        return {
            "code": result.response.content,
            "agent": result.agent_name,
            "execution_time_ms": result.execution_time_ms
        }
```

### Updated Security Phase

```python
# agents/security/security_lead.py

from core import MultiAgentOrchestrator, Task, TaskType, AgentCapability

class SecurityLead:
    def __init__(self):
        self.orchestrator = MultiAgentOrchestrator()

    async def security_audit(self, code, criticality="high"):
        """
        Phase 3: Security

        With multi-agent:
        - Use parallel execution for critical code (consensus)
        - Use single agent for non-critical code (fast)
        """

        task = Task(
            type=TaskType.SECURITY_AUDIT,
            description=f"""
            Security audit for:
            {code}

            Check:
            - OWASP Top 10
            - Authentication/Authorization
            - Input validation
            - SQL injection
            - XSS vulnerabilities
            - CSRF protection
            """,
            context={
                "system": "Comprehensive security assessment",
                "temperature": 0.2
            },
            required_capability=AgentCapability.SECURITY
        )

        # Strategy based on criticality
        strategy = "parallel" if criticality == "high" else "best_agent"

        result = await self.orchestrator.execute_task(task, strategy=strategy)

        return {
            "vulnerabilities": parse_vulnerabilities(result.response.content),
            "agent": result.agent_name,
            "confidence": "high" if strategy == "parallel" else "medium"
        }
```

## Configuration

### Environment Setup

```bash
# Required
export ANTHROPIC_API_KEY="sk-ant-..."

# Optional (for full multi-agent capabilities)
export GOOGLE_API_KEY="AIza..."
export GITHUB_TOKEN="ghp_..."
export OPENAI_API_KEY="sk-..."
```

### Agent Priority Configuration

Customize agent priorities in `core/agent_registry.py`:

```python
def initialize_default_agents():
    registry = get_registry()

    # Customize priorities based on your needs
    registry.register_agent(AgentConfig(
        provider=AgentProvider.CLAUDE,
        name="claude-sonnet",
        priority=10,  # Highest - preferred for most tasks
        # ...
    ))

    registry.register_agent(AgentConfig(
        provider=AgentProvider.GEMINI,
        name="gemini-pro",
        priority=8,   # High - for multimodal and long context
        # ...
    ))

    # Adjust priorities to change selection preference
```

## Best Practices

### 1. Choose Appropriate Strategies

```python
# ✅ Good: Parallel for critical decisions
await orchestrator.execute_task(
    security_critical_task,
    strategy="parallel"  # Multiple perspectives
)

# ❌ Bad: Parallel for simple tasks
await orchestrator.execute_task(
    simple_formatting_task,
    strategy="parallel"  # Wasteful
)
```

### 2. Set Realistic Token Limits

```python
# ✅ Good: Appropriate limits
task = Task(
    description="Generate login component",
    context={"max_tokens": 2000}  # Sufficient
)

# ❌ Bad: Excessive limits
task = Task(
    description="Generate login component",
    context={"max_tokens": 100000}  # Wasteful
)
```

### 3. Monitor Agent Health

```python
# Check health before critical operations
registry = get_registry()
health = registry.get_health_report()

if health['healthy_agents'] < 2:
    print("⚠️ Warning: Low agent availability")
    # Maybe delay execution or notify admin
```

### 4. Handle Failures Gracefully

```python
result = await orchestrator.execute_task(task, strategy="fallback")

if not result.success:
    print(f"All agents failed: {result.error}")
    # Fallback to manual process or queue for retry
else:
    print(f"Completed by {result.agent_name}")
```

## Performance Metrics

### Typical Execution Times

| Strategy | Small Task | Medium Task | Large Task |
|----------|-----------|-------------|-----------|
| best_agent | 2-5s | 5-15s | 15-45s |
| fallback | 2-5s (1st try) | 5-15s (1st try) | 15-45s (1st try) |
| parallel | 6-15s (3x agents) | 15-45s (3x agents) | 45-135s (3x agents) |
| pipeline (5 steps) | 10-25s | 25-75s | 75-225s |

### Cost Comparison

| Workflow | Single Agent | Multi-Agent (Mixed) | Savings/Cost |
|----------|-------------|---------------------|--------------|
| Simple feature | $0.10 | $0.15 | +50% cost |
| Complex feature | $0.50 | $0.75 | +50% cost |
| Critical feature | $0.50 | $1.50 (parallel) | +200% cost |
| **ROI vs Manual** | **97% savings** | **96% savings** | **Still massive** |

**Key Insight:** Even with parallel execution, multi-agent is 96%+ cheaper than manual development.

## Migration Guide

### Step 1: Update Imports

```python
# Old
from agents.design.architect import Architect

# New
from agents.design.architect import Architect
from core import MultiAgentOrchestrator
```

### Step 2: Initialize Orchestrator

```python
# In your persona class __init__
class Architect:
    def __init__(self):
        self.orchestrator = MultiAgentOrchestrator()
```

### Step 3: Replace Direct API Calls

```python
# Old
response = claude_api.generate(prompt)

# New
task = Task(
    type=TaskType.ARCHITECTURE_DESIGN,
    description=prompt,
    required_capability=AgentCapability.ARCHITECTURE
)
result = await self.orchestrator.execute_task(task)
response = result.response.content
```

### Step 4: Test with Examples

```bash
cd examples/multi-agent-demo
python quickstart.py
```

## Troubleshooting

### Common Issues

**Issue 1: Import errors**
```python
# Error
ModuleNotFoundError: No module named 'core'

# Fix
sys.path.insert(0, str(Path(__file__).parent.parent))
from core import MultiAgentOrchestrator
```

**Issue 2: No agents available**
```python
# Error
No agent available for code_generation

# Fix
1. Check API keys: echo $ANTHROPIC_API_KEY
2. Verify initialization: initialize_default_agents() was called
3. Check agent health: get_registry().get_health_report()
```

**Issue 3: Slow execution**
```python
# Reduce max_tokens
task.context["max_tokens"] = 2000  # Instead of 10000

# Use best_agent instead of parallel
strategy = "best_agent"  # Instead of "parallel"
```

## Examples

See `/examples/multi-agent-demo/` for complete examples:
- `quickstart.py`: Simple test examples
- `full_workflow_example.py`: Complete feature development pipeline
- `README.md`: Comprehensive documentation

## Next Steps

1. **Review Examples:** Study `/examples/multi-agent-demo/`
2. **Run Quick Start:** Test with `quickstart.py`
3. **Integrate One Persona:** Start with Architect or Developer
4. **Monitor Performance:** Track execution times and costs
5. **Expand Gradually:** Add to more personas as comfortable
6. **Optimize Strategies:** Experiment with best_agent vs parallel vs fallback

## Summary

Multi-agent integration provides:
- ✅ **Reliability:** Automatic fallback on failures
- ✅ **Flexibility:** Use best agent for each task
- ✅ **Consensus:** Multiple perspectives for critical decisions
- ✅ **Scalability:** Handle tasks beyond single agent limits
- ✅ **Cost Control:** Choose strategies based on task criticality

**Impact:**
- 97% time reduction (same as single agent)
- 0% → 100% reliability (automatic fallback)
- Single perspective → Multiple perspectives (parallel mode)
- 200K token limit → 1M+ token limit (Gemini long context)
