# Multi-Agent System Demo

Complete examples demonstrating Master Agent's multi-agent orchestration capabilities.

## Overview

This demo shows how Master Agent coordinates multiple AI providers (Claude, Gemini, Copilot, OpenAI) to execute complex development workflows with intelligent routing, parallel execution, and automatic fallback.

## Quick Start

### 1. Install Dependencies

```bash
pip install anthropic google-generativeai httpx
```

### 2. Set API Keys

```bash
# Required
export ANTHROPIC_API_KEY="sk-ant-..."

# Optional (for full multi-agent capabilities)
export GOOGLE_API_KEY="AIza..."
export GITHUB_TOKEN="ghp_..."
export OPENAI_API_KEY="sk-..."
```

### 3. Run Quick Start Test

```bash
cd examples/multi-agent-demo
python quickstart.py
```

**Expected Output:**
```
======================================================================
MULTI-AGENT SYSTEM - QUICK START
======================================================================

üîë API Key Status:
   ‚úÖ ANTHROPIC_API_KEY
   ‚úÖ GOOGLE_API_KEY
   ‚ùå GITHUB_TOKEN
   ‚ùå OPENAI_API_KEY

======================================================================
AGENT HEALTH STATUS
======================================================================
   ‚úÖ claude-sonnet (claude)
   ‚úÖ gemini-pro (gemini)
   ...

TEST 1: Single Agent Execution
   ‚úÖ Success! Agent: claude-sonnet
   Generated code: [Fibonacci implementation]

TEST 2: Fallback Strategy
   ‚úÖ Success! Agent: claude-sonnet
   Architecture design: [Microservices architecture]

TEST 3: Sequential Pipeline
   ‚úÖ Step 1: architecture_design (claude-sonnet)
   ‚úÖ Step 2: code_generation (claude-sonnet)
   ‚úÖ Step 3: security_audit (claude-sonnet)

‚úÖ ALL TESTS COMPLETED
```

## Examples

### Example 1: Quick Start (`quickstart.py`)

Simple tests demonstrating core multi-agent capabilities:
- **Test 1**: Single agent execution (best agent selection)
- **Test 2**: Automatic fallback on failure
- **Test 3**: Sequential pipeline (3-step workflow)

**Usage:**
```bash
python quickstart.py
```

**What it demonstrates:**
- Agent registry and health monitoring
- Capability-based routing
- Automatic agent selection
- Pipeline execution with context passing

### Example 2: Full Workflow (`full_workflow_example.py`)

Complete feature development workflow for "Smart Document Analyzer":

**5-Phase Pipeline:**
1. **UI Analysis** (Gemini - Multimodal): Analyze design mockup ‚Üí Extract requirements
2. **Architecture Design** (Claude): Design React component architecture
3. **Code Generation** (Parallel): Multiple agents generate code ‚Üí Consensus
4. **Security Audit** (Parallel): All agents audit for vulnerabilities
5. **Final Review** (Claude): Quality gate approval

**Usage:**
```bash
python full_workflow_example.py
```

**Expected Output:**
```
======================================================================
PHASE 1: UI Mockup Analysis (Gemini - Multimodal)
======================================================================
‚úÖ Analysis completed by gemini-pro
   Requirements extracted: [Component specifications]

======================================================================
PHASE 2: Architecture Design (Claude - System Design)
======================================================================
‚úÖ Architecture designed by claude-sonnet
   Architecture highlights: [Component tree, data flow]

======================================================================
PHASE 3: Code Generation (Parallel - Multiple Agents)
======================================================================
‚úÖ Code generated by claude-sonnet
   Generated components: [React TypeScript code]

======================================================================
PHASE 4: Security Audit (Parallel - Consensus)
======================================================================
‚úÖ Security audit completed
   Security findings: [Vulnerability assessment]

======================================================================
PHASE 5: Final Code Review (Claude - Quality Gate)
======================================================================
‚úÖ Review completed by claude-sonnet
   Review summary: [APPROVED / NEEDS_CHANGES]

======================================================================
WORKFLOW COMPLETE
======================================================================
   Total execution time: 15.2s
   Total tokens used: 24,500
   Phases completed: 5/5
   ‚úÖ Ready for deployment!
```

**What it demonstrates:**
- Real-world feature development workflow
- Multimodal capabilities (Gemini with images)
- Parallel execution for consensus
- Sequential pipeline with context passing
- Comprehensive security review
- Production-ready deployment approval

## Architecture

### Multi-Agent Orchestration

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MultiAgentOrchestrator                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ              Execution Strategies                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ best_agent: Route to single best agent        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ parallel: Execute on multiple agents          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ fallback: Try alternatives on failure         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ pipeline: Sequential with context chaining    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Agent Registry                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ          Capability-Based Routing                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Match task requirements to agent capabilities ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Health monitoring (success/error rates)       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Priority-based selection                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Automatic agent exclusion on failure          ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚ñº                 ‚ñº                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Claude (Sonnet) ‚îÇ ‚îÇ   Gemini    ‚îÇ ‚îÇ  Copilot    ‚îÇ
‚îÇ                 ‚îÇ ‚îÇ             ‚îÇ ‚îÇ             ‚îÇ
‚îÇ ‚Ä¢ Architecture  ‚îÇ ‚îÇ ‚Ä¢ Multimodal‚îÇ ‚îÇ ‚Ä¢ Code Gen  ‚îÇ
‚îÇ ‚Ä¢ Code Review   ‚îÇ ‚îÇ ‚Ä¢ Long Ctx  ‚îÇ ‚îÇ ‚Ä¢ Completion‚îÇ
‚îÇ ‚Ä¢ Security      ‚îÇ ‚îÇ ‚Ä¢ Real-time ‚îÇ ‚îÇ             ‚îÇ
‚îÇ ‚Ä¢ 200K tokens   ‚îÇ ‚îÇ ‚Ä¢ 1M tokens ‚îÇ ‚îÇ ‚Ä¢ 8K tokens ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Agent Selection Logic

```python
def get_agent_for_task(required_capability):
    """
    Selection criteria (in order):
    1. Has required capability
    2. Is healthy and enabled
    3. Not in excluded list
    4. Highest priority
    5. Lowest error rate
    """
    candidates = filter_by_capability_and_health(agents)
    candidates.sort(key=lambda x: (-priority, error_rate))
    return candidates[0]
```

### Execution Strategies

#### 1. Best Agent (Single)
```python
result = await orchestrator.execute_task(task, strategy="best_agent")
# Routes to single best agent based on capabilities and health
```

**Use when:**
- Standard task execution
- Cost optimization priority
- Single perspective sufficient

#### 2. Parallel Execution
```python
result = await orchestrator.execute_task(task, strategy="parallel")
# Executes on ALL capable agents, returns consensus
```

**Use when:**
- Multiple perspectives valuable (code review, security audit)
- High confidence required (critical decisions)
- Willing to trade cost for consensus

**How it works:**
```
Task ‚Üí [Agent 1, Agent 2, Agent 3] (parallel)
         ‚Üì        ‚Üì        ‚Üì
    Result 1  Result 2  Result 3
         ‚Üì        ‚Üì        ‚Üì
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚ñº
          Consensus Logic
          (currently: most comprehensive)
                  ‚ñº
           Final Result
```

#### 3. Automatic Fallback
```python
result = await orchestrator.execute_task(task, strategy="fallback")
# Tries agents sequentially until one succeeds
```

**Use when:**
- Reliability priority over consistency
- Acceptable to have different agents for retries
- Want automatic recovery from failures

**How it works:**
```
Task ‚Üí Agent 1 (highest priority)
         ‚Üì
      Failed?
         ‚Üì
Task ‚Üí Agent 2 (second priority)
         ‚Üì
      Success!
         ‚Üì
    Return Result
```

#### 4. Sequential Pipeline
```python
results = await orchestrator.execute_pipeline([task1, task2, task3])
# Each task output becomes input to next task
```

**Use when:**
- Multi-step workflows
- Context accumulation needed
- Output ‚Üí Input chaining required

**How it works:**
```
Task 1 ‚Üí Agent A ‚Üí Result 1
                      ‚Üì
         Context = {step_1: Result 1}
                      ‚Üì
Task 2 ‚Üí Agent B ‚Üí Result 2 (uses Result 1)
                      ‚Üì
         Context = {step_1: Result 1, step_2: Result 2}
                      ‚Üì
Task 3 ‚Üí Agent C ‚Üí Result 3 (uses Result 1 + 2)
```

## Configuration

### Agent Capabilities

Each agent is registered with specific capabilities:

```python
# Claude (Primary - Highest priority)
AgentConfig(
    provider=AgentProvider.CLAUDE,
    model="claude-sonnet-4-5",
    capabilities=[
        AgentCapability.CODE_GENERATION,
        AgentCapability.CODE_REVIEW,
        AgentCapability.ARCHITECTURE,
        AgentCapability.SECURITY,
        AgentCapability.LONG_CONTEXT  # 200K tokens
    ],
    max_tokens=200000,
    priority=10
)

# Gemini (Multimodal + Long Context)
AgentConfig(
    provider=AgentProvider.GEMINI,
    model="gemini-2.0-flash-exp",
    capabilities=[
        AgentCapability.CODE_GENERATION,
        AgentCapability.MULTIMODAL,  # Images, audio, video
        AgentCapability.LONG_CONTEXT,  # 1M+ tokens
        AgentCapability.REAL_TIME
    ],
    max_tokens=1000000,
    priority=8
)

# Copilot (Code Completion Specialist)
AgentConfig(
    provider=AgentProvider.COPILOT,
    model="gpt-4",
    capabilities=[
        AgentCapability.CODE_COMPLETION,
        AgentCapability.CODE_GENERATION
    ],
    max_tokens=8000,
    priority=7
)
```

### Task Types

```python
class TaskType(Enum):
    CODE_GENERATION = "code_generation"
    CODE_REVIEW = "code_review"
    ARCHITECTURE_DESIGN = "architecture_design"
    SECURITY_AUDIT = "security_audit"
    DOCUMENTATION = "documentation"
    MULTIMODAL_ANALYSIS = "multimodal_analysis"
    REAL_TIME_COLLABORATION = "real_time_collaboration"
```

### Health Monitoring

Agents are continuously monitored for health:

```python
@dataclass
class AgentHealth:
    agent_name: str
    is_healthy: bool
    last_check: datetime
    response_time_ms: float
    error_rate: float  # failure_count / (success_count + failure_count)
    success_count: int
    failure_count: int

# Automatic health degradation
if error_rate > 0.5:  # 50% error rate
    agent.is_healthy = False
    # Agent excluded from selection until manual re-enable
```

## API Reference

### MultiAgentOrchestrator

```python
orchestrator = MultiAgentOrchestrator()

# Execute single task
result = await orchestrator.execute_task(
    task=Task(...),
    strategy="best_agent" | "parallel" | "fallback"
)

# Execute pipeline (sequential tasks)
results = await orchestrator.execute_pipeline(
    tasks=[task1, task2, task3]
)
```

### Task Creation

```python
task = Task(
    type=TaskType.CODE_GENERATION,
    description="Your task description",
    context={
        "system": "System instruction for agent",
        "temperature": 0.7,
        "max_tokens": 4000,
        "images": ["base64_image"]  # For multimodal
    },
    required_capability=AgentCapability.CODE_GENERATION,
    priority=1
)
```

### Agent Registry

```python
from core import get_registry

registry = get_registry()

# Get health report
health = registry.get_health_report()
print(f"Healthy agents: {health['healthy_agents']}/{health['total_agents']}")

# Get agents by capability
agents = registry.get_agents_by_capability(AgentCapability.MULTIMODAL)
```

## Real-World Use Cases

### Use Case 1: Multi-Perspective Code Review

```python
# Get consensus from multiple agents on code quality
review_task = Task(
    type=TaskType.CODE_REVIEW,
    description="Review authentication.py for quality and security",
    required_capability=AgentCapability.CODE_REVIEW
)

# Parallel execution ‚Üí multiple perspectives
result = await orchestrator.execute_task(review_task, strategy="parallel")
# Result combines insights from Claude, Gemini, Copilot
```

**Value:**
- Catch issues one agent might miss
- Multiple security perspectives
- Higher confidence in approval

### Use Case 2: Design ‚Üí Code ‚Üí Review Pipeline

```python
tasks = [
    # Step 1: Design with Claude (architecture specialist)
    Task(
        type=TaskType.ARCHITECTURE_DESIGN,
        description="Design payment processing system",
        required_capability=AgentCapability.ARCHITECTURE
    ),

    # Step 2: Generate code with Copilot (code specialist)
    Task(
        type=TaskType.CODE_GENERATION,
        description="Implement design from step 1",
        required_capability=AgentCapability.CODE_GENERATION
    ),

    # Step 3: Security audit with Claude (security specialist)
    Task(
        type=TaskType.SECURITY_AUDIT,
        description="Audit code from step 2",
        required_capability=AgentCapability.SECURITY
    )
]

results = await orchestrator.execute_pipeline(tasks)
```

**Value:**
- Each agent contributes their strength
- Context flows through pipeline
- Comprehensive quality assurance

### Use Case 3: Multimodal Analysis

```python
# Analyze UI mockup with Gemini's vision capabilities
design_task = Task(
    type=TaskType.MULTIMODAL_ANALYSIS,
    description="Extract component specs from mockup",
    context={
        "images": [base64_encode(open("mockup.png", "rb").read())]
    },
    required_capability=AgentCapability.MULTIMODAL
)

result = await orchestrator.execute_task(design_task)
# Gemini analyzes image ‚Üí extracts UI requirements
```

**Value:**
- Bridge design ‚Üí code gap
- Automated requirement extraction
- Faster design implementation

## Troubleshooting

### Issue: All agents failing

**Symptoms:**
```
‚ùå Analysis failed: No agent available for code_generation
```

**Solutions:**
1. Check API keys are set correctly
2. Verify agent health: `python -c "from core import get_registry; import asyncio; print(get_registry().get_health_report())"`
3. Check network connectivity
4. Review API rate limits

### Issue: Slow execution times

**Symptoms:**
```
Execution time: 45000ms (45 seconds)
```

**Solutions:**
1. Reduce `max_tokens` in task context
2. Use `strategy="best_agent"` instead of `"parallel"`
3. Check for network latency
4. Consider caching for repeated tasks

### Issue: High error rates

**Symptoms:**
```
Agent marked unhealthy. Error rate: 75%
```

**Solutions:**
1. Check API key validity
2. Review task descriptions for clarity
3. Verify `required_capability` matches agent capabilities
4. Check API quota/rate limits
5. Review recent API changes for provider

## Performance Optimization

### Token Usage

```python
# ‚ùå Inefficient: Large context, low value
task = Task(
    description="Entire codebase analysis...",  # 50K tokens
    context={"max_tokens": 100000}
)

# ‚úÖ Efficient: Focused task, targeted analysis
task = Task(
    description="Review auth.py lines 45-120 for SQL injection",  # 500 tokens
    context={"max_tokens": 2000}
)
```

**Savings:** 95% token reduction

### Execution Strategy

```python
# ‚ùå Expensive: Parallel for simple task
result = await orchestrator.execute_task(
    simple_task,
    strategy="parallel"  # 3x cost
)

# ‚úÖ Cost-effective: Best agent for simple task
result = await orchestrator.execute_task(
    simple_task,
    strategy="best_agent"  # 1x cost
)
```

**Rule:** Use parallel only when consensus adds value

### Caching

```python
# For repeated tasks, cache results
from functools import lru_cache

@lru_cache(maxsize=100)
async def cached_execute(task_hash):
    return await orchestrator.execute_task(task)
```

## Integration with Master Agent

### SDLC Phase Integration

```python
# In Master Agent workflow (e.g., Design phase)
from core import MultiAgentOrchestrator, Task, TaskType, AgentCapability

async def design_phase(prd_content):
    orchestrator = MultiAgentOrchestrator()

    # Use Gemini for multimodal PRD analysis
    if has_diagrams(prd_content):
        task = Task(
            type=TaskType.MULTIMODAL_ANALYSIS,
            description=f"Analyze PRD with diagrams: {prd_content}",
            context={"images": extract_diagrams(prd_content)},
            required_capability=AgentCapability.MULTIMODAL
        )
        result = await orchestrator.execute_task(task)

    # Use Claude for architecture design
    arch_task = Task(
        type=TaskType.ARCHITECTURE_DESIGN,
        description=f"Design system architecture for: {result.response.content}",
        required_capability=AgentCapability.ARCHITECTURE
    )
    arch_result = await orchestrator.execute_task(arch_task)

    return arch_result
```

### Persona Enhancement

```python
# Security Lead persona with multi-agent audit
class SecurityLead:
    async def security_review(self, code):
        orchestrator = MultiAgentOrchestrator()

        task = Task(
            type=TaskType.SECURITY_AUDIT,
            description=f"Comprehensive security audit:\n{code}",
            required_capability=AgentCapability.SECURITY
        )

        # Get consensus from multiple agents
        result = await orchestrator.execute_task(task, strategy="parallel")

        return result.response.content
```

## Cost Analysis

### Typical Costs (Estimated)

**Single Agent Execution:**
- Small task (500 tokens): ~$0.01
- Medium task (2000 tokens): ~$0.04
- Large task (8000 tokens): ~$0.15

**Parallel Execution (3 agents):**
- Small task: ~$0.03 (3x)
- Medium task: ~$0.12 (3x)
- Large task: ~$0.45 (3x)

**Full Workflow Example:**
- 5 phases, ~25K total tokens
- Single agent strategy: ~$0.50
- Mixed strategy (1 parallel): ~$0.75

**ROI:**
- Manual feature development: 10 hours @ $100/hr = $1,000
- Multi-agent automated: 15 minutes + $0.75 = ~$25.75
- **Savings: ~97%** ($974.25 per feature)

## Next Steps

1. **Run Quick Start:** `python quickstart.py`
2. **Customize Task:** Modify `quickstart.py` with your own tasks
3. **Test Full Workflow:** `python full_workflow_example.py`
4. **Integrate with Master Agent:** Use in SDLC workflows
5. **Monitor Performance:** Track token usage and execution times
6. **Optimize Strategies:** Experiment with best_agent vs parallel vs fallback

## Resources

- **Setup Guide:** `/MULTI_AGENT_SETUP_GUIDE.md`
- **Architecture Docs:** `/core/multi_agent_orchestrator.py`
- **Agent Registry:** `/core/agent_registry.py`
- **Integrations:** `/core/agent_integrations.py`

## Support

For issues or questions:
1. Check troubleshooting section above
2. Review agent health status
3. Verify API keys and quotas
4. Test with `quickstart.py`
5. Review execution logs for errors
